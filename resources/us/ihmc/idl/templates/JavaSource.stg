group ProtocolHeader;

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "PubSubTypes.java"], description=["This class contains the implementation of the serialization functions."])$

$if(!ctx.isPackageEmpty)$
package $ctx.onlyPackage$;
$endif$ 
import us.ihmc.rtps.TopicDataType;

$definitions; separator="\n"$

>>

module(ctx, parent, module, definition_list) ::= <<
public class $module.name$
{
    $definition_list$
} //End of namespace $module.name$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$

>>

annotation(ctx, annotation) ::= <<>>

interface(ctx, parent, interface, export_list) ::= <<
$export_list$
>>

export_list(exports) ::= <<
$exports; separator="\n"$

>>

exception(ctx, parent, exception) ::= <<>>

operation(ctx, parent, operation, param_list) ::= <<>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

const_decl(ctx, parent, const) ::= <<>>

typedef_decl(ctx, parent, typedefs) ::= <<>>

struct_type(ctx, parent, struct) ::= <<

public class $if(parent.IsInterface)$$parent.name$_$endif$$struct.name$PubSubType extends TopicDataType<$struct.name$>
{
	private final String name = "$struct.scopedname$";
	
	

$if(parent.IsInterface)$$parent.name$_$endif$$struct.name$PubSubType::$if(parent.IsInterface)$$parent.name$_$endif$$struct.name$PubSubType() {
	setName("$struct.scopedname$");
	m_typeSize = (uint32_t)$if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$::getMaxCdrSerializedSize();
	m_isGetKeyDefined = $if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$::isKeyDefined();
	m_keyBuffer = (unsigned char*)malloc($if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$::getKeyMaxCdrSerializedSize()>16 ? $if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$::getKeyMaxCdrSerializedSize() : 16);
}

$if(parent.IsInterface)$$parent.name$_$endif$$struct.name$PubSubType::~$if(parent.IsInterface)$$parent.name$_$endif$$struct.name$PubSubType() {
	if(m_keyBuffer!=nullptr)
		free(m_keyBuffer);
}

@Override
boolean serialize($struct.name$ data, SerializedPayload payload) 
{
	
	eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
	eprosima::fastcdr::Cdr ser(fastbuffer); 	// Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
	p_type->serialize(ser); 	// Serialize the object:
    payload->length = (uint32_t)ser.getSerializedDataLength(); 	//Get the serialized length
	return true;
}

bool $if(parent.IsInterface)$$parent.name$_$endif$$struct.name$PubSubType::deserialize(SerializedPayload_t* payload, void* data) {
	$if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$* p_type = ($if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$*) data; 	//Convert DATA to pointer of your type
	eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); 	// Object that manages the raw buffer.
	eprosima::fastcdr::Cdr deser(fastbuffer, payload->encapsulation == CDR_BE ? eprosima::fastcdr::Cdr::BIG_ENDIANNESS : eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS); 	// Object that deserializes the data.
	p_type->deserialize(deser);	//Deserialize the object:
	return true;
}

std::function<uint32_t()> $if(parent.IsInterface)$$parent.name$_$endif$$struct.name$PubSubType::getSerializedSizeProvider(void* data) {
    return [data]() -> uint32_t { return (uint32_t)type::getCdrSerializedSize(*static_cast<$if(parent.IsInterface)$$parent.name$_$endif$$struct.name$*>(data)); };
}

void* $if(parent.IsInterface)$$parent.name$_$endif$$struct.name$PubSubType::createData() {
	return (void*)new $if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$();
}

void $if(parent.IsInterface)$$parent.name$_$endif$$struct.name$PubSubType::deleteData(void* data) {
	delete(($if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$*)data);
}

bool $if(parent.IsInterface)$$parent.name$_$endif$$struct.name$PubSubType::getKey(void *data, InstanceHandle_t* handle) {
	if(!m_isGetKeyDefined)
		return false;
	$if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$* p_type = ($if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$*) data;
	eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,$if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
	eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
	p_type->serializeKey(ser);
	if($if(parent.IsInterface)$$struct.scopedname$$else$$struct.name$$endif$::getKeyMaxCdrSerializedSize()>16)	{
		m_md5.init();
		m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
		m_md5.finalize();
		for(uint8_t i = 0;i<16;++i)    	{
        	handle->value[i] = m_md5.digest[i];
    	}
    }
    else    {
    	for(uint8_t i = 0;i<16;++i)    	{
        	handle->value[i] = m_keyBuffer[i];
    	}
    }
	return true;
}

>>

union_type(ctx, parent, union) ::= <<>>

enum_type(ctx, parent, enum) ::= <<>>
