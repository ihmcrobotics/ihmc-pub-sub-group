// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
// Copyright 2017 Florida Institute for Human And Machine Cognition (IHMC)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group JavaType;

main(ctx, definitions, package) ::= <<
$fileHeader()$
$if(package)$
package $package$;
$endif$

import us.ihmc.idl.IDLSequence;
import us.ihmc.idl.CDR;
import us.ihmc.idl.IDLStruct;
import java.util.Arrays;

$definitions$
>>

interface(ctx, parent, interface, exports, extension) ::= <<
$classdescription(type="interface", name=interface.name, filename=[ctx.filename, ".idl"])$
public interface $interface.name$
{
    $extension$

    $exports$
}
>>

struct_type(ctx, parent, struct, extension) ::= <<
$classdescription(type="class", name=struct.name, filename=[ctx.filename, ".idl"])$
public class $struct.name$ implements IDLStruct<$struct.name$>
{
    public $struct.name$()
    {
        $struct.members : { member | $if(member.typecode.isType_e)$
	$if(member.typecode.ContentTypeCode.isType_c)$
	$member.name$_ = new $member.typecode.javaTypename$($member.typecode.Maxsize$, $member.typecode.ContentTypeCode.javaTypename$.class, $member.typecode.ContentTypeCode.javaTypename$.values);
	$elseif(member.typecode.ContentTypeCode.primitive)$
	$member.name$_ = new $member.typecode.javaTypename$($member.typecode.Maxsize$, "$member.typecode.ContentTypeCode.stType$");
	$elseif(member.typecode.ContentTypeCode.isType_d)$
	$member.name$_ = new $member.typecode.javaTypename$($member.typecode.Maxsize$, "$member.typecode.ContentTypeCode.stType$");   
	$else$
	$member.name$_ = new $member.typecode.javaTypename$($member.typecode.Maxsize$, $member.typecode.ContentTypeCode.JavaTypename$.class, new $member.typecode.ContentTypeCode.JavaTypename$PubSubType());
	$endif$
	$elseif(member.typecode.isType_f)$
	$member.name$_ = new $member.typecode.ContentTypeCode.JavaTypename$[$member.typecode.Dimensions;separator="]["$];
	$if(!member.typecode.ContentTypeCode.primitive)$
	$array_init(ctx=ctx, typecodeArr=member.typecode, data=[member.name, "_"], elemInit=["new ", member.typecode.ContentTypeCode.JavaTypename, "()"], loopvar=ctx.nextLoopVarName, dimensions=member.typecode.dimensions)$
	$endif$
	$elseif(member.typecode.isType_d)$
	$member.name$_ = new $member.typecode.javaTypename$($member.typecode.Maxsize$); 
	$elseif(!member.typecode.primitive)$
	$member.name$_ = new $member.typecode.javaTypename$();
	$else$
	$endif$
}; separator=""$
        
        
    }
    @Override
    public void set($struct.name$ other)
    {
        $struct.members : { member | $if(member.typecode.primitive)$
	$member.name$_ = other.$member.name$_;
    $elseif(member.typecode.isType_d)$
	$member.name$_.setLength(0);
	$member.name$_.append(other.$member.name$_);
   	$elseif(member.typecode.isType_f)$
	$array_copy(ctx=ctx, typecodeArr=member.typecode, data=[member.name, "_"], other=["other.", member.name, "_"], loopvar=ctx.nextLoopVarName, dimensions=member.typecode.dimensions)$
	
   	$else$
	$member.name$_.set(other.$member.name$_);
    $endif$}; separator=""$
    }

    $struct.members : { member |
    $if(!member.typecode.isType_e)$
    $if(member.typecode.primitive)$
public void set$member.javaName$($member.typecode.javaTypename$ $member.name$)
{
    $member.name$_ = $member.name$;
}
    $endif$
    $endif$

public $member.typecode.javaTypename$ get$member.javaName$()
{
    return $member.name$_;
}

    }; separator="\n"$


	public static int getMaxCdrSerializedSize()
	{
		return getMaxCdrSerializedSize(0);
	}

	public static int getMaxCdrSerializedSize(int current_alignment)
	{
	    int initial_alignment = current_alignment;
	            
	    $struct.members : { member |$max_serialized_size(ctx=ctx, typecode=member.typecode, var="current_alignment")$}; separator="\n"$
	
	    return current_alignment - initial_alignment;
	}


	public final static int getCdrSerializedSize($struct.name$ data)
	{
		return getCdrSerializedSize(data, 0);
	}

	public final static int getCdrSerializedSize($struct.name$ data, int current_alignment)
	{
	    int initial_alignment = current_alignment;
	            
	    $struct.members : { member |$serialized_size(ctx=ctx, object=member, data="data", var="current_alignment")$}; separator="\n"$
	
	    return current_alignment - initial_alignment;
	}
	
	@Override
	public final void serialize(CDR cdr)
	{

	    $struct.members : { member |$object_serialization(ctx=ctx, object=member, postfix="_")$}; separator="\n"$
	}
	
	@Override
	public final void deserialize(CDR cdr)
	{
	    $struct.members : { member |$object_deserialization(ctx=ctx, object=member, postfix="_")$}; separator="\n"$
	}

    @Override
    public boolean equals(Object other)
    {
        if(other == null) return false;
        if(other == this) return true;
        if(!(other instanceof $struct.name$)) return false;
        $struct.name$ otherMyClass = ($struct.name$)other;
        boolean returnedValue = true;

        $struct.members : { member |
        $if(member.typecode.primitive)$returnedValue &= this.$member.name$_ == otherMyClass.$member.name$_;
        $elseif(member.typecode.isType_d)$returnedValue &= us.ihmc.idl.IDLTools.equals(this.$member.name$_, otherMyClass.$member.name$_);
       	$elseif(member.typecode.isType_f)$
        	$array_equals(ctx=ctx, typecodeArr=member.typecode, data=[member.name, "_"], loopvar=ctx.nextLoopVarName, other=["otherMyClass.", member.name, "_"], bool=["returnedValue"], dimensions=member.typecode.dimensions)$
        $else$returnedValue &= this.$member.name$_.equals(otherMyClass.$member.name$_);
        $endif$
        }; separator="\n"$

        return returnedValue;
    }
    
     @Override
    public String toString()
    {
		StringBuilder builder = new StringBuilder();
		
      	builder.append("$struct.name$ {");
        $struct.members : { member |
builder.append("$member.name$=");
$if(member.typecode.isType_f)$
$if(first(rest(member.typecode.dimensions)))$builder.append(Arrays.deepToString(this.$member.name$_));
$else$builder.append(Arrays.toString(this.$member.name$_));
$endif$
$else$builder.append(this.$member.name$_);$endif$

        }; separator="builder.append(\", \");\n"$
        builder.append("}");
		return builder.toString();
    }

    $struct.members : { member |private $member.typecode.javaTypename$ $member.name$_; }; separator="\n"$

    $extension$
}
>>

union_type(ctx, parent, union, extension) ::= <<
$classdescription(type="union", name=union.name, filename=[ctx.filename, ".idl"])$
public class $union.name$
{
    public $union.name$()
    {
        $if(union.javaDefaultvalue)$
        d__ = $union.javaDefaultvalue$;
        $else$
        d__ = $first(first(union.members).javaLabels)$;
        $endif$

        $union.members : { member |
        $if(!member.typecode.primitive)$$member.name$_ = new $member.typecode.javaTypename$();$endif$
        }; separator="\n"$
    }

    public $union.discriminator.javaTypename$ getDiscriminator()
    {
        return d__;
    }

    $union.members : { member |
    $if(!member.typecode.isType_e)$
    public void set$member.javaName$($member.typecode.javaTypename$ $member.name$)
    {
        $member.name$_ = $member.name$;

        $if(member.default)$
            d__ = $union.javaDefaultvalue$;
        $else$
            d__ = $first(member.javaLabels)$;
        $endif$
    }

    public void set$member.javaName$($union.discriminator.javaTypename$ discriminator, $member.typecode.javaTypename$ $member.name$)
        throws Exception
    {
        $if(member.default)$
        if($[union.javaDefaultvalue, member.javaLabels] : {label | discriminator == $label$}; separator=" || "$)
        $else$
        if($member.javaLabels : {label | discriminator == $label$}; separator=" || "$)
        $endif$
        {
            $member.name$_ = $member.name$;
            d__ = discriminator;
            return;
        }

        throw new Exception("Given discriminator is not a valid value for member $member.name$");
    }
    $endif$

    public $member.typecode.javaTypename$ get$member.javaName$()
        throws Exception
    {
        $if(member.default)$
        if($[union.javaDefaultvalue, member.javaLabels] : {label | d__ == $label$}; separator=" || "$)
        $else$
        if($member.javaLabels : {label | d__ == $label$}; separator=" || "$)
        $endif$
            return $member.name$_;

        throw new Exception("Union member not selected by discriminator");
    }

    }; separator="\n"$

    @Override
    public boolean equals(Object other)
    {
        if(other == null) return false;
        if(other == this) return true;
        if(!(other instanceof $union.name$)) return false;
        $union.name$ otherMyClass = ($union.name$)other;

        if(this.d__ == otherMyClass.d__)
        {
            $union.members : { member |
                $if(member.default)$
                if($[union.javaDefaultvalue, member.javaLabels] : {label | d__ == $label$}; separator=" || "$)
                $else$
                if($member.javaLabels : {label | d__ == $label$}; separator=" || "$)
                $endif$
                {
                    if(this.$member.name$_ == otherMyClass.$member.name$_)
                        return true;
                    else
                        return false;
                }
        }; separator="\n"$
        }

        return false;
    }

    $union.discriminator.javaTypename$ d__;

    $union.members : { member |private $member.typecode.javaTypename$ $member.name$_; }; separator="\n"$

    $extension$
}
>>

enum_type(ctx, parent, enum, extension) ::= <<
$classdescription(type="enum", name=enum.name, filename=[ctx.filename, ".idl"])$
public enum $enum.name$ implements IDLStruct<$enum.name$>
{
    $enum.members:{ member |
    	$member.name$,
    }; separator="\n"$
	;
	
	public static $enum.name$[] values = values();

    $extension$
}
>>
