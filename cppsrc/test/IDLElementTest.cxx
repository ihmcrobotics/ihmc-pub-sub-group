// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file IDLElementTest.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "IDLElementTest.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

IDLElement::NestedElement::NestedElement()
{

    m_longTest = 0;
}

IDLElement::NestedElement::~NestedElement()
{
}

IDLElement::NestedElement::NestedElement(const NestedElement &x)
{
    m_stringTest = x.m_stringTest;
    m_longTest = x.m_longTest;
}

IDLElement::NestedElement::NestedElement(NestedElement &&x)
{
    m_stringTest = std::move(x.m_stringTest);
    m_longTest = x.m_longTest;
}

IDLElement::NestedElement& IDLElement::NestedElement::operator=(const NestedElement &x)
{
    m_stringTest = x.m_stringTest;
    m_longTest = x.m_longTest;
    
    return *this;
}

IDLElement::NestedElement& IDLElement::NestedElement::operator=(NestedElement &&x)
{
    m_stringTest = std::move(x.m_stringTest);
    m_longTest = x.m_longTest;
    
    return *this;
}

size_t IDLElement::NestedElement::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t IDLElement::NestedElement::getCdrSerializedSize(const IDLElement::NestedElement& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.stringTest().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void IDLElement::NestedElement::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    if(m_stringTest.length() <= 255)
    scdr << m_stringTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("stringTest field exceeds the maximum length");
    scdr << m_longTest;

}

void IDLElement::NestedElement::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_stringTest;
    dcdr >> m_longTest;
}

size_t IDLElement::NestedElement::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool IDLElement::NestedElement::isKeyDefined()
{
    return false;
}

void IDLElement::NestedElement::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}

IDLElement::IDLElementTest::IDLElementTest()
{
    m_charTest = 0;
    m_wcharTest = 0;
    m_octetTest = 0;
    m_shortTest = 0;
    m_ushortTest = 0;
    m_longTest = 0;
    m_ulongTest = 0;
    m_longlongTest = 0;
    m_ulonglongTest = 0;
    m_floatTest = 0.0;
    m_doubleTest = 0.0;
    m_booleanTest = false;
    m_colorTest = IDLElement::red;



















}

IDLElement::IDLElementTest::~IDLElementTest()
{
}

IDLElement::IDLElementTest::IDLElementTest(const IDLElementTest &x)
{
    m_charTest = x.m_charTest;
    m_wcharTest = x.m_wcharTest;
    m_octetTest = x.m_octetTest;
    m_shortTest = x.m_shortTest;
    m_ushortTest = x.m_ushortTest;
    m_longTest = x.m_longTest;
    m_ulongTest = x.m_ulongTest;
    m_longlongTest = x.m_longlongTest;
    m_ulonglongTest = x.m_ulonglongTest;
    m_floatTest = x.m_floatTest;
    m_doubleTest = x.m_doubleTest;
    m_booleanTest = x.m_booleanTest;
    m_colorTest = x.m_colorTest;
    m_nestedElementTest = x.m_nestedElementTest;
    m_stringTest = x.m_stringTest;
    m_longArray = x.m_longArray;
    m_nestedArray = x.m_nestedArray;
    m_stringArray = x.m_stringArray;
    m_charSeqTest = x.m_charSeqTest;
    m_wcharSeqTest = x.m_wcharSeqTest;
    m_octetSeqTest = x.m_octetSeqTest;
    m_shortSeqTest = x.m_shortSeqTest;
    m_ushortSeqTest = x.m_ushortSeqTest;
    m_longSeqTest = x.m_longSeqTest;
    m_ulongSeqTest = x.m_ulongSeqTest;
    m_longlongSeqtest = x.m_longlongSeqtest;
    m_ulonglongSeqTest = x.m_ulonglongSeqTest;
    m_floatSeqTest = x.m_floatSeqTest;
    m_doubleSeqTest = x.m_doubleSeqTest;
    m_booleanSeqTest = x.m_booleanSeqTest;
    m_nestedSeqTest = x.m_nestedSeqTest;
    m_stringSeqTest = x.m_stringSeqTest;
}

IDLElement::IDLElementTest::IDLElementTest(IDLElementTest &&x)
{
    m_charTest = x.m_charTest;
    m_wcharTest = x.m_wcharTest;
    m_octetTest = x.m_octetTest;
    m_shortTest = x.m_shortTest;
    m_ushortTest = x.m_ushortTest;
    m_longTest = x.m_longTest;
    m_ulongTest = x.m_ulongTest;
    m_longlongTest = x.m_longlongTest;
    m_ulonglongTest = x.m_ulonglongTest;
    m_floatTest = x.m_floatTest;
    m_doubleTest = x.m_doubleTest;
    m_booleanTest = x.m_booleanTest;
    m_colorTest = x.m_colorTest;
    m_nestedElementTest = std::move(x.m_nestedElementTest);
    m_stringTest = std::move(x.m_stringTest);
    m_longArray = std::move(x.m_longArray);
    m_nestedArray = std::move(x.m_nestedArray);
    m_stringArray = std::move(x.m_stringArray);
    m_charSeqTest = std::move(x.m_charSeqTest);
    m_wcharSeqTest = std::move(x.m_wcharSeqTest);
    m_octetSeqTest = std::move(x.m_octetSeqTest);
    m_shortSeqTest = std::move(x.m_shortSeqTest);
    m_ushortSeqTest = std::move(x.m_ushortSeqTest);
    m_longSeqTest = std::move(x.m_longSeqTest);
    m_ulongSeqTest = std::move(x.m_ulongSeqTest);
    m_longlongSeqtest = std::move(x.m_longlongSeqtest);
    m_ulonglongSeqTest = std::move(x.m_ulonglongSeqTest);
    m_floatSeqTest = std::move(x.m_floatSeqTest);
    m_doubleSeqTest = std::move(x.m_doubleSeqTest);
    m_booleanSeqTest = std::move(x.m_booleanSeqTest);
    m_nestedSeqTest = std::move(x.m_nestedSeqTest);
    m_stringSeqTest = std::move(x.m_stringSeqTest);
}

IDLElement::IDLElementTest& IDLElement::IDLElementTest::operator=(const IDLElementTest &x)
{
    m_charTest = x.m_charTest;
    m_wcharTest = x.m_wcharTest;
    m_octetTest = x.m_octetTest;
    m_shortTest = x.m_shortTest;
    m_ushortTest = x.m_ushortTest;
    m_longTest = x.m_longTest;
    m_ulongTest = x.m_ulongTest;
    m_longlongTest = x.m_longlongTest;
    m_ulonglongTest = x.m_ulonglongTest;
    m_floatTest = x.m_floatTest;
    m_doubleTest = x.m_doubleTest;
    m_booleanTest = x.m_booleanTest;
    m_colorTest = x.m_colorTest;
    m_nestedElementTest = x.m_nestedElementTest;
    m_stringTest = x.m_stringTest;
    m_longArray = x.m_longArray;
    m_nestedArray = x.m_nestedArray;
    m_stringArray = x.m_stringArray;
    m_charSeqTest = x.m_charSeqTest;
    m_wcharSeqTest = x.m_wcharSeqTest;
    m_octetSeqTest = x.m_octetSeqTest;
    m_shortSeqTest = x.m_shortSeqTest;
    m_ushortSeqTest = x.m_ushortSeqTest;
    m_longSeqTest = x.m_longSeqTest;
    m_ulongSeqTest = x.m_ulongSeqTest;
    m_longlongSeqtest = x.m_longlongSeqtest;
    m_ulonglongSeqTest = x.m_ulonglongSeqTest;
    m_floatSeqTest = x.m_floatSeqTest;
    m_doubleSeqTest = x.m_doubleSeqTest;
    m_booleanSeqTest = x.m_booleanSeqTest;
    m_nestedSeqTest = x.m_nestedSeqTest;
    m_stringSeqTest = x.m_stringSeqTest;
    
    return *this;
}

IDLElement::IDLElementTest& IDLElement::IDLElementTest::operator=(IDLElementTest &&x)
{
    m_charTest = x.m_charTest;
    m_wcharTest = x.m_wcharTest;
    m_octetTest = x.m_octetTest;
    m_shortTest = x.m_shortTest;
    m_ushortTest = x.m_ushortTest;
    m_longTest = x.m_longTest;
    m_ulongTest = x.m_ulongTest;
    m_longlongTest = x.m_longlongTest;
    m_ulonglongTest = x.m_ulonglongTest;
    m_floatTest = x.m_floatTest;
    m_doubleTest = x.m_doubleTest;
    m_booleanTest = x.m_booleanTest;
    m_colorTest = x.m_colorTest;
    m_nestedElementTest = std::move(x.m_nestedElementTest);
    m_stringTest = std::move(x.m_stringTest);
    m_longArray = std::move(x.m_longArray);
    m_nestedArray = std::move(x.m_nestedArray);
    m_stringArray = std::move(x.m_stringArray);
    m_charSeqTest = std::move(x.m_charSeqTest);
    m_wcharSeqTest = std::move(x.m_wcharSeqTest);
    m_octetSeqTest = std::move(x.m_octetSeqTest);
    m_shortSeqTest = std::move(x.m_shortSeqTest);
    m_ushortSeqTest = std::move(x.m_ushortSeqTest);
    m_longSeqTest = std::move(x.m_longSeqTest);
    m_ulongSeqTest = std::move(x.m_ulongSeqTest);
    m_longlongSeqtest = std::move(x.m_longlongSeqtest);
    m_ulonglongSeqTest = std::move(x.m_ulonglongSeqTest);
    m_floatSeqTest = std::move(x.m_floatSeqTest);
    m_doubleSeqTest = std::move(x.m_doubleSeqTest);
    m_booleanSeqTest = std::move(x.m_booleanSeqTest);
    m_nestedSeqTest = std::move(x.m_nestedSeqTest);
    m_stringSeqTest = std::move(x.m_stringSeqTest);
    
    return *this;
}

size_t IDLElement::IDLElementTest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += IDLElement::NestedElement::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < (5 * 3); ++a)
    {
        current_alignment += IDLElement::NestedElement::getMaxCdrSerializedSize(current_alignment);}
    for(size_t a = 0; a < (4); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (25 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 25; ++a)
    {
        current_alignment += IDLElement::NestedElement::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 25; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    }

    return current_alignment - initial_alignment;
}

size_t IDLElement::IDLElementTest::getCdrSerializedSize(const IDLElement::IDLElementTest& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += IDLElement::NestedElement::getCdrSerializedSize(data.nestedElementTest(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.stringTest().size() + 1;

    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.nestedArray().size(); ++a)
    {
        for(size_t b = 0; b < data.nestedArray().at(a).size(); ++b)
        {
                current_alignment += IDLElement::NestedElement::getCdrSerializedSize(data.nestedArray().at(a).at(b), current_alignment);
        }
    }
    for(size_t a = 0; a < data.stringArray().size(); ++a)
    {
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.stringArray().at(a).size() + 1;

    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.charSeqTest().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.wcharSeqTest().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.octetSeqTest().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.shortSeqTest().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.ushortSeqTest().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.longSeqTest().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.ulongSeqTest().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.longlongSeqtest().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.ulonglongSeqTest().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.floatSeqTest().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.doubleSeqTest().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.booleanSeqTest().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.nestedSeqTest().size(); ++a)
    {
        current_alignment += IDLElement::NestedElement::getCdrSerializedSize(data.nestedSeqTest().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.stringSeqTest().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.stringSeqTest().at(a).size() + 1;
    }

    return current_alignment - initial_alignment;
}

void IDLElement::IDLElementTest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_charTest;

    scdr << m_wcharTest;

    scdr << m_octetTest;

    scdr << m_shortTest;

    scdr << m_ushortTest;

    scdr << m_longTest;

    scdr << m_ulongTest;

    scdr << m_longlongTest;

    scdr << m_ulonglongTest;

    scdr << m_floatTest;

    scdr << m_doubleTest;

    scdr << m_booleanTest;

    scdr << (uint32_t)m_colorTest;

    scdr << m_nestedElementTest;

    if(m_stringTest.length() <= 255)
    scdr << m_stringTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("stringTest field exceeds the maximum length");
    scdr << m_longArray;

    scdr << m_nestedArray;

    scdr << m_stringArray;

    if(m_charSeqTest.size() <= 25)
    scdr << m_charSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("charSeqTest field exceeds the maximum length");
    if(m_wcharSeqTest.size() <= 25)
    scdr << m_wcharSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("wcharSeqTest field exceeds the maximum length");
    if(m_octetSeqTest.size() <= 25)
    scdr << m_octetSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("octetSeqTest field exceeds the maximum length");
    if(m_shortSeqTest.size() <= 25)
    scdr << m_shortSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("shortSeqTest field exceeds the maximum length");
    if(m_ushortSeqTest.size() <= 25)
    scdr << m_ushortSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("ushortSeqTest field exceeds the maximum length");
    if(m_longSeqTest.size() <= 25)
    scdr << m_longSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("longSeqTest field exceeds the maximum length");
    if(m_ulongSeqTest.size() <= 25)
    scdr << m_ulongSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("ulongSeqTest field exceeds the maximum length");
    if(m_longlongSeqtest.size() <= 25)
    scdr << m_longlongSeqtest;
    else
        throw eprosima::fastcdr::exception::BadParamException("longlongSeqtest field exceeds the maximum length");
    if(m_ulonglongSeqTest.size() <= 25)
    scdr << m_ulonglongSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("ulonglongSeqTest field exceeds the maximum length");
    if(m_floatSeqTest.size() <= 25)
    scdr << m_floatSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("floatSeqTest field exceeds the maximum length");
    if(m_doubleSeqTest.size() <= 25)
    scdr << m_doubleSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("doubleSeqTest field exceeds the maximum length");
    if(m_booleanSeqTest.size() <= 25)
    scdr << m_booleanSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("booleanSeqTest field exceeds the maximum length");
    if(m_nestedSeqTest.size() <= 25)
    scdr << m_nestedSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("nestedSeqTest field exceeds the maximum length");
    if(m_stringSeqTest.size() <= 25)
    scdr << m_stringSeqTest;
    else
        throw eprosima::fastcdr::exception::BadParamException("stringSeqTest field exceeds the maximum length");
}

void IDLElement::IDLElementTest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_charTest;
    dcdr >> m_wcharTest;
    dcdr >> m_octetTest;
    dcdr >> m_shortTest;
    dcdr >> m_ushortTest;
    dcdr >> m_longTest;
    dcdr >> m_ulongTest;
    dcdr >> m_longlongTest;
    dcdr >> m_ulonglongTest;
    dcdr >> m_floatTest;
    dcdr >> m_doubleTest;
    dcdr >> m_booleanTest;
    dcdr >> (uint32_t&)m_colorTest;
    dcdr >> m_nestedElementTest;
    dcdr >> m_stringTest;
    dcdr >> m_longArray;
    dcdr >> m_nestedArray;
    dcdr >> m_stringArray;
    dcdr >> m_charSeqTest;
    dcdr >> m_wcharSeqTest;
    dcdr >> m_octetSeqTest;
    dcdr >> m_shortSeqTest;
    dcdr >> m_ushortSeqTest;
    dcdr >> m_longSeqTest;
    dcdr >> m_ulongSeqTest;
    dcdr >> m_longlongSeqtest;
    dcdr >> m_ulonglongSeqTest;
    dcdr >> m_floatSeqTest;
    dcdr >> m_doubleSeqTest;
    dcdr >> m_booleanSeqTest;
    dcdr >> m_nestedSeqTest;
    dcdr >> m_stringSeqTest;
}

size_t IDLElement::IDLElementTest::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

































    return current_align;
}

bool IDLElement::IDLElementTest::isKeyDefined()
{
    return false;
}

void IDLElement::IDLElementTest::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
}
